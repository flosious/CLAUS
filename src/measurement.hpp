/*
	Copyright (C) 2020 Florian BÃ¤rwolf
	floribaer@gmx.de

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
#ifndef MEASUREMENT_T_HPP
#define MEASUREMENT_T_HPP

#include <vector>
#include "quantity.hpp"
#include "isotope.hpp"
#include "statistics.hpp"
#include "config.hpp"
#include "crater_t.hpp"
#include "filename_t.hpp"
#include "database_t.hpp"
#include "measurement_settings_t.hpp"
#include "sample_t.hpp"

class cluster_t;
class measurement_group_t;

/*handles ONE measurement*/
class measurement_t
{
	friend class parser_methods;
private:
// 	vector<string> calc_history_p;
	
	/// reference calculation_methode
	string reference_calculation_method="";
	bool secondary=false;
	/// "NULL" if whole measurement_t is empty and will be skipped
	string tool_name_p="NULL";
	bool loaded_from_database=false;
	
	vector<cluster_t*> reference_clusters_p;
	map<string, quantity_t> reference_clusters_concentrations_p;
	map<string, quantity_t> reference_clusters_intensities_p;
	vector<string> error_messages_p;
// 	int equilibrium_starting_pos_p=-1;
	
// 	set<isotope_t> isotopes_from_clusters_p;
public:
// 	vector<string> calc_history();
	/// all isotopes within this measurement
	set<isotope_t> isotopes();
	/// calculates the equlibirum position of the measurement within the data points (0 to end)
// 	int equilibrium_starting_pos();
// 	map<string, cluster_t> equlibrium_clusters_storage;
	measurement_group_t* measurement_group;
	filename_t* filename_p;
	measurement_settings_t settings;
	sample_t* sample_p;
// 	measurement_group_t* measurement_group_p;
	
	/// return the pointers to the reference clusters within the measurement
	vector<cluster_t*> reference_clusters();
	/// returns the cluster belonging to the isotope or element
	cluster_t* reference_cluster(isotope_t& isotope_or_element);
	/// from reference samples, if found in DB
// 	map<string,quantity_t> reference_clusters_concentrations();
	/// utilize the median of each measurement
// 	map<string,quantity_t> reference_clusters_intensities();
	
	bool load_from_database();
	bool save_to_database();
	
	string lot();
	int wafer();
	int chip_x();
	int chip_y();
	string monitor();
	
	string tool_name();
	int group();
	int olcdb();
	/// start of measurement
	string date_time_start;
	/// stop of measurement
	string date_time_stop;
	/// if the measurement was repeated: "q,w,e,r,t,z,....,qq,qw,....,eq,..." behind the group, see filename_t for detailed definition
	string repetition();
	/// e.g. crater measurements from dektak32 are secondary measurements and will be added to non-secondary measurements
	bool is_secondary();
	/// true if this measurement can be used as reference
	bool is_reference();
	
	/// vector<y(x)data>
	pair<quantity_t,quantity_t> spectrum;
	/// all clusters: e.g. "74Ge1 31P1"(first) -> cluster_t (second)
// 	list<cluster_t> clusters;
	map<string, cluster_t> clusters;
	/// crater generated by measurement
	crater_t crater;
	/// changes the depth depth_resolution 
// 	void depth_resolution();
	
	vector<string> error_messages();

	bool operator == (const measurement_t& measurement);
	bool operator != (const measurement_t& measurement);
	
	string to_str(string prefix="");
	void to_screen(string prefix="");
	static void to_screen(vector<measurement_t>* measurements);

};

#endif // MEASUREMENT_T_HPP
