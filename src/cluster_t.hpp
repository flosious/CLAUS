/*
	Copyright (C) 2020 Florian Bärwolf
	baerwolf@ihp-microelectronics.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
#ifndef CLUSTER_T_HPP
#define CLUSTER_T_HPP

#include <vector>
// #include "pse.hpp"
#include <regex>
#include "quantity.hpp"
#include <utility>
#include <regex>
#include "pse.hpp"
#include <set>
#include "isotope.hpp"
#include "calc_models_t.hpp"
#include "globalvars.hpp"

// #include "sample_t.hpp"
// #include "measurement_group_t.hpp"

using namespace std;

// class analyzer_t;
class measurement_t;

/*input/name should be something like: 30Si2 1H O2 and if not - it doesn t matter at all*/
class cluster_t
{
	friend class crater_t;
	friend class xps_csv_t;
	friend class dsims_asc_t;
	friend class tofsims_txt_t;
	friend class parser_methods;
	friend class calc_models_t;
// 	friend class calc_models_t::jiang_t;
// 	friend class measurement_t;
private:
	
	bool quantities_reduced_by_equilibrium_starting_pos=false;
	void reduce_quantities_by_equlibrium_starting_pos(cluster_t& reduces_this);
// 	vector<quantity_t*> in_calculation_list_p;
	quantity_t reduce_quantity_by_equlibrium_starting_pos(quantity_t& quantity);
// 	cluster_t* equlibrium_p=nullptr;
// 	vector<string> delimiters={","," ",";"};
	string name_p="";
	/// for evaluating the concentration and depth
// 	analyzer_t* analyzer;
	
	quantity_t maximum_concentration_p;
	quantity_t depth_at_maximum_concentration_p;
	
// 	vector<string> calc_history_p;
	vector<string> error_messages_p;
	
	/// individual sputter_time; overwrites pointer to crater->sputter_time
	quantity_t sputter_time_p;
	/// individual sputter_depth; overwrites pointer to crater->sputter_depth
	quantity_t sputter_depth_p;
	/// individual sputter_rate; overwrites pointer to crater->sputter_rate
	quantity_t sputter_rate_p;
	
// 	RSF_t RSF_p;
	quantity_t dose_p;
	quantity_t intensity_p;
	quantity_t concentration_p;
	/// pointer to -> crater
// 	quantity_t *sputter_depth_p;
	/// pointer to -> crater
	quantity_t SF_p;
	quantity_t RSF_p;
	quantity_t reference_intensity_p;
// 	bool reference=false;
	
	bool already_checked_concentration=false;
	bool already_checked_dose=false;
	bool already_checked_intensity=false;
	bool already_checked_SF=false;
	bool already_checked_RSF=false;
	bool already_checked_sputter_depth=false;
	bool already_checked_sputter_time=false;
	bool already_checked_sputter_rate=false;
	
	
public:
	int equilibrium_starting_pos=-1;
// 	calc_models_t 
// 	vector<string> settings;
	
	measurement_t* measurement;
	vector<string> error_messages();
	/// returns the mass of the whole cluster
	quantity_t mass();
	quantity_t abundance();
	/// name generated by isotopes -> e.g. "31P1 74Ge1"
	string name();
	/// true, if both clusters are the same
// 	bool is_same(cluster_t *cluster_p);
	
	/// physikalische größen, z.B. "mass", "abundance" oder "concentration"

	/// list of all isotopes included within this cluster
	vector<isotope_t> isotopes; // map<isotope_t,int> isotope->#atoms
	
	/// at/ccm
	void set_maximum_concentration_p(double& value);
	void set_maximum_concentration_p(quantity_t& quantity);
	/// nm
	void set_depth_at_maximum_concentration_p(double& value);
	void set_depth_at_maximum_concentration_p(quantity_t& quantity);
	void set_dose_p(double& value);
	void set_dose_p(quantity_t& quantity);
// 	void set_reference(bool value);
	
	bool is_reference();
	/// checks cluster for all isotopes(symbols+nukleons)
	bool are_isotopes_in_cluster(vector<isotope_t> isotopes_p);
	/// checks cluster for all isotopes.symbols
	bool are_elements_in_cluster(vector<isotope_t> isotopes_p);
	bool is_isotope_in_cluster(isotope_t isotope);
	bool is_element_in_cluster(isotope_t isotope);
	/// returns cluster.isotopes - isotopes
	vector<isotope_t> leftover_isotopes(vector<isotope_t> isotopes_p);
	/// returns cluster.isotopes.symbols - isotopes.symbols
	vector<isotope_t> leftover_elements(vector<isotope_t> isotopes_p);
	
	isotope_t reference_matrix_isotope();
	
	/// all the intensities of all matrix clusters (e.g. 30Si + 70Ge)
	quantity_t reference_intensity();
	quantity_t SF();
	quantity_t RSF();
	quantity_t sputter_rate();
	quantity_t dose();
	quantity_t intensity();
	quantity_t concentration();
	quantity_t sputter_depth();
	quantity_t sputter_time();
	quantity_t maximum_concentration();
	quantity_t depth_at_maximum_concentration();
	
	quantity_t total_sputter_time();
	quantity_t total_sputter_depth();
	
	/*! returns this cluster within its sputter equlibrium state
	 *  its a little bit complicated because iterative use is forbidden
	 */
	cluster_t equilibrium();
	
	void to_screen(string prefix="");
};

#endif // CLUSTER_T_HPP
